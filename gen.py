#!/usr/bin/env python3

from os import fdopen, unlink, rename
from yaml import load, dump
from tempfile import mkstemp

COMMON_FILE_HEADER = """\
// This file automaticaly generated by gen.py
"""

NOT_ARGS = set(['return', 'need_coroutine'])

class FileBase(object):
    def __init__(self, filename):
        self.filename = filename

    def __enter__(self):
        tmp_handle, tmp_filename = mkstemp()
        self.file = fdopen(tmp_handle, "wb")
        self.tmp_filename = tmp_filename
        self.print(COMMON_FILE_HEADER)
        return self

    def __exit__(self, exc_type, exc_value, traceback):
        if exc_type is not None or exc_value is not None or traceback is not None:
            unlink(self.tmp_filename)
            raise
        rename(self.tmp_filename, self.filename)

    def print(self, data=None, end='\n'):
        if data is not None:
            self.write(bytes(data, encoding='ascii'))
        if end is not None:
            self.write(bytes(end, encoding='ascii'))

    def write(self, data):
        self.file.write(data)

class hpp(FileBase):
    def __init__(self, filename):
        FileBase.__init__(self, filename)

    def __enter__(self):
        FileBase.__enter__(self)
        self.print('#pragma once')
        self.print('')
        return self

class cpp(FileBase):
    def __init__(self, filename):
        FileBase.__init__(self, filename)

class NamespaceCommon(object):
    def __init__(self, f, text, start='{text}\n{{', end='}} // {text}'):
        self.file = f
        self.text = text
        self.start = start
        self.end = end

    def __enter__(self):
        self.file.print(self.start.format(text=self.text))
        return self.file

    def __exit__(self, exc_type, exc_value, traceback):
        if exc_type is not None or exc_value is not None or traceback is not None:
            raise
        self.file.print(self.end.format(text=self.text))
        self.file.print()

class ifdef(NamespaceCommon):
    def __init__(self, f, macro):
        NamespaceCommon.__init__(self, f, text=macro, start='#ifdef {text}', end="#endif // {text}")

class ifndef(NamespaceCommon):
    def __init__(self, f, macro):
        NamespaceCommon.__init__(self, f, text=macro, start='#ifndef {text}', end="#endif // {text}")

class extern_C(NamespaceCommon):
    def __init__(self, f):
        NamespaceCommon.__init__(self, f, 'extern "C"')

class Function(object):
    def __init__(self, f, function_name, function_spec):
        self.file = f
        self.function_name = function_name
        self.function_spec = function_spec

    def __enter__(self):
        self.file.print(declare_function(self.function_name, self.function_spec))
        self.print('{')
        return self

    def __exit__(self, exc_type, exc_value, traceback):
        if exc_type is not None or exc_value is not None or traceback is not None:
            raise
        self.print('}} // {function_name}'.format(function_name=self.function_name))
        self.file.print()

    def print(self, data=None, end='\n'):
        if data is not None:
            self.file.write(b'    ')
        self.file.print(data, end=end)


def validate(allowed_types, variable_type):
    ignored_tokens = set(['struct', 'const'])
    tokens = variable_type.split(' ')
    tokens = list(filter(lambda x: x not in ignored_tokens, tokens))
    if len(tokens) != 1:
        raise Exception('too many tokens: {}'.format(tokens))
    token = tokens[0]
    while token[-1] == '*':
        token = token[:-1]
    if token not in allowed_types:
        raise Exception('type "{}" is not allowed'.format(token))

def make_function_type_name(function_name):
    return '{function_name}_type'.format(function_name=function_name)

def make_function_ptr_name(function_name):
    return '{function_name}_ptr'.format(function_name=function_name);

def make_function_args(function_spec):
    return ', '.join([variable_name for variable_name, variable_type in function_spec.items() if variable_name not in NOT_ARGS])

def make_global_include(filename):
    return '#include <{filename}>'.format(filename=filename)

def make_real_function_name(function_name):
    return '__real_{function_name}'.format(function_name=function_name)

def make_wrap_function_name(function_name):
    return '__wrap_{function_name}'.format(function_name=function_name)

def declare_function_args(function_spec):
    return ', '.join(['{variable_type} {variable_name}'.format(variable_type=variable_type, variable_name=variable_name) for variable_name, variable_type in function_spec.items() if variable_name not in NOT_ARGS])

def declare_function_type(function_name, function_spec):
    return_type = function_spec['return']
    args = declare_function_args(function_spec)
    return 'typedef {return_type} (*{function_type_name})({args})'.format(function_type_name=make_function_type_name(function_name), return_type=return_type, args=args)

def declare_variable(variable_name, variable_type):
    return '{variable_type} {variable_name}'.format(variable_name=variable_name, variable_type=variable_type)

def declare_function_pointer(function_name):
    return declare_variable(variable_name=make_function_ptr_name(function_name), variable_type=make_function_type_name(function_name))

def declare_function(function_name, function_spec, width=0):
    return_type = function_spec['return']
    args = declare_function_args(function_spec)
    return '{return_type:<{width}} {function_name}({args})'.format(function_name=function_name, return_type=return_type, args=args, width=width)

def generate_shared(includes, functions):
    def declare_real(function_name, function_spec):
        real_function_name = make_real_function_name(function_name)
        function_ptr_name=make_function_ptr_name(function_name)
        function_declaration = declare_function(function_name=real_function_name, function_spec=function_spec)
        function_body = '{{ return {function_ptr_name}({function_args}); }}'.format(function_ptr_name=function_ptr_name, function_args=make_function_args(function_spec))
        return '{function_declaration} {function_body}'.format(function_declaration=function_declaration, function_body=function_body)

    def declare_hook(function_name, function_spec):
        wrap_function_name = make_wrap_function_name(function_name)
        function_declaration = declare_function(function_name=function_name, function_spec=function_spec)
        function_body = '{{ return {wrap_function_name}({function_args}); }}'.format(wrap_function_name=wrap_function_name, function_args=make_function_args(function_spec))
        return '{function_declaration} {function_body}'.format(function_declaration=function_declaration, function_body=function_body)

    def declare___hook(function_name, function_spec):
        wrap_function_name = make_wrap_function_name(function_name)
        function_declaration = declare_function(function_name='__'+function_name, function_spec=function_spec)
        function_body = '{{ return {wrap_function_name}({function_args}); }}'.format(wrap_function_name=wrap_function_name, function_args=make_function_args(function_spec))
        return '{function_declaration} {function_body}'.format(function_declaration=function_declaration, function_body=function_body)

    def declare___close_nocancel():
        function_declaration = declare_function(function_name='__close_nocancel', function_spec={'return':'int', 'fd': 'int'})
        function_body = '{ return __wrap_close(fd); }'
        return '{function_declaration} {function_body}'.format(function_declaration=function_declaration, function_body=function_body)

    def write_init(f, functions):
        f.print('__attribute__((constructor)) static')
        with Function(f, function_name='init', function_spec={'return': 'void'}) as current_function:
            for function_name, function_spec in functions.items():
                function_pointer = make_function_ptr_name(function_name=function_name)
                current_function.print('{function_pointer} = reinterpret_cast<{function_type}>(dlsym(RTLD_NEXT, "{function_name}"));'.format(function_type=make_function_type_name(function_name), function_pointer=function_pointer, function_name=function_name))
            current_function.print('yurco::init(1024*1024);')

    with cpp('shared.cpp') as f:
        for include in includes:
            f.print(make_global_include(include))
        f.print()
        f.print('#include "transparency.hpp"')
        f.print()
        with extern_C(f) as extern:
            for function_name, function_spec in functions.items():
                extern.print(declare_function_type(function_name, function_spec), end=';\n')
            extern.print()
            for function_name, function_spec in functions.items():
                extern.print(declare_function_pointer(function_name), end=' = nullptr;\n')
            extern.print()
            for function_name, function_spec in functions.items():
                extern.print(declare_real(function_name, function_spec))
            extern.print()
            for function_name, function_spec in functions.items():
                extern.print(declare_hook(function_name, function_spec))
                extern.print(declare___hook(function_name, function_spec))
            extern.print(declare___close_nocancel())
            extern.print()
            write_init(extern, functions)

def generate_transparency(includes, functions):
    generate_transparency_hpp(includes, functions)
    generate_transparency_cpp(includes, functions)

def generate_transparency_hpp(includes, functions):
    def write_inline_real_functions(stream, functions):
        with ifndef(stream, 'YURCO_TRANSPARENCY'):
            with extern_C(stream):
                for function_name, function_spec in functions.items():
                    real_function_name = make_real_function_name(function_name)
                    function_declaration = '__inline__  ' + declare_function(real_function_name, function_spec, width=7)
                    args = make_function_args(function_spec)
                    function_body = '{{ return ::{function_name}({args}); }}'.format(function_name=function_name, args=args)
                    stream.print(function_declaration, end=' ')
                    stream.print(function_body)
                stream.print()
                for function_name, function_spec in functions.items():
                    real_function_name = make_real_function_name('__'+function_name)
                    function_declaration = '__inline__  ' + declare_function(real_function_name, function_spec, width=7)
                    args = make_function_args(function_spec)
                    function_body = '{{ return ::{function_name}({args}); }}'.format(function_name=function_name, args=args)
                    stream.print(function_declaration, end=' ')
                    stream.print(function_body)

    with hpp('transparency.hpp') as stream:
        for include in includes:
            stream.print(make_global_include(include))
        stream.print()
        write_inline_real_functions(stream, functions)
        with ifdef(stream, 'YURCO_TRANSPARENCY'):
            stream.print('#include "operations.hpp"')
            stream.print()
            with extern_C(stream):
                for function_name, function_spec in functions.items():
                    real_function_name = make_real_function_name(function_name)
                    stream.print(declare_function(function_name=real_function_name, function_spec=function_spec, width=7), end=';\n')
                stream.print()
                for function_name, function_spec in functions.items():
                    wrap_function_name = make_wrap_function_name(function_name)
                    stream.print(declare_function(function_name=wrap_function_name, function_spec=function_spec, width=7), end=';\n')
                stream.print()
                for function_name, function_spec in functions.items():
                    real_function_name = make_real_function_name('__'+function_name)
                    stream.print(declare_function(function_name=real_function_name, function_spec=function_spec, width=7), end=';\n')
                stream.print()
                for function_name, function_spec in functions.items():
                    wrap_function_name = make_wrap_function_name('__'+function_name)
                    stream.print(declare_function(function_name=wrap_function_name, function_spec=function_spec, width=7), end=';\n')

def generate_transparency_cpp(includes, functions):
    with cpp('transparency.cpp') as stream:
        with ifdef(stream, 'YURCO_TRANSPARENCY'):
            stream.print('#include "transparency.hpp"')
            stream.print()
            with extern_C(stream):
                for function_name, function_spec in functions.items():
                    wrap_function_name = make_wrap_function_name(function_name)
                    args = make_function_args(function_spec)
                    function_declaration = declare_function(function_name=wrap_function_name, function_spec=function_spec)
                    function_body_with_coro = '{{ return yurco::{function_name}(std::nothrow, *yurco::get_reactor(), *yurco::get_coroutine(), {args}); }}'.format(function_name=function_name, args=args)
                    function_body_without_coro = '{{ return yurco::{function_name}(std::nothrow, *yurco::get_reactor(), {args}); }}'.format(function_name=function_name, args=args)
                    need_coroutine = function_spec.get('need_coroutine', True)
                    stream.print(function_declaration, end=' ')
                    stream.print(function_body_with_coro if need_coroutine else function_body_without_coro)
                for function_name, function_spec in functions.items():
                    wrap_function_name = make_wrap_function_name('__'+function_name)
                    args = make_function_args(function_spec)
                    function_declaration = declare_function(function_name=wrap_function_name, function_spec=function_spec)
                    function_body_with_coro = '{{ return yurco::{function_name}(std::nothrow, *yurco::get_reactor(), *yurco::get_coroutine(), {args}); }}'.format(function_name=function_name, args=args)
                    function_body_without_coro = '{{ return yurco::{function_name}(std::nothrow, *yurco::get_reactor(), {args}); }}'.format(function_name=function_name, args=args)
                    need_coroutine = function_spec.get('need_coroutine', True)
                    stream.print(function_declaration, end=' ')
                    stream.print(function_body_with_coro if need_coroutine else function_body_without_coro)

def main():
    with open('functions.yml') as f:
        data = load(f)
        includes = data['includes']
        allowed_types = set(data['types'])
        functions = data['functions']
        for function_name, function_spec in functions.items():
            for variable_name, variable_type in function_spec.items():
                if variable_name not in NOT_ARGS:
                    validate(allowed_types, variable_type)

        generate_shared(includes, functions)
        generate_transparency(includes, functions)

main()

